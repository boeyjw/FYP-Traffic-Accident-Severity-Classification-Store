library(party)
help(ctree)
col(iris)
head(iris)
ctree(formula = Species ~ Petal.Length + Petal.Width, data = iris)
plot(ctree(formula = Species ~ Petal.Length + Petal.Width, data = iris))
library(caret)
install.packages("caret")
devtools::install_github("rstudio/keras")
install.packages("devtools")
devtools::install_github("rstudio/keras")
devtools::install_github("rstudio/keras")
library(RTools)
devtools::install_github("rstudio/keras")
remove.packages(keras)
remove.packages(:)
remove.packages("keras")
load("~/Dataset/UK_Car_Accidents_1979-2016/alldataloaded_proccessed.RData")
common <- intersect(Accidents2016, Casualties2016)
remove(common)
cac2016 <- intersect(Accidents2016$Accident_Index, Casualties2016$Accident_Index)
cac2016
cav2016 <- intersect(Accidents2016, Vehicles2016)
remove(cav2016)
cav2016 <- intersect(Accidents2016$Accident_Index, Vehicles2016$Accident_Index)
c2016 <- intersect(cac2016, cav2016)
c2016
install.packages('dplyr')
quit
quit()
x <- c(0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,3,3,3,0,0,0,0)
p <- matrix(nrow = 4, ncol = 4, 0)
for (t in 1:(length(x) - 1)) p[x[t], x[t + 1]] <- p[x[t], x[t + 1]] + 1
for (i in 1:4) p[i, ] <- p[i, ] / sum(p[i, ])
p
x <- c(0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,3,3,3,0,0,0,0)
p <- matrix(nrow = 4, ncol = 4, 0)
for (t in 1:(length(x) - 1)) p[x[t], x[t + 1]] <- p[x[t], x[t + 1]] + 1
for (i in 0:3) p[i, ] <- p[i, ] / sum(p[i, ])
p
p[1, ]
setwd('h:/gbaccident0516/')
veh = read.csv('veh2005_2016-v2018.2.3-tobeimp.csv')
fun_imp <- function(cl, data, X = 1:detectCores() - 2, m = 1, imp_meth, pred_mat, maxit = 5) {
imp_data <- data[[1]][c(),]
imp_merge <<- vector(mode = 'list', length = length(data))
print('Start Imputation')
for (n in 1:length(data)) {
imp_pairs <- parLapply(cl = cl, X = X, fun = function(no, d, m, method, predictionMatrix, maxit) {
mice(d, m = m, printFlag = FALSE, method = method, maxit = maxit, predictorMatrix = predictionMatrix)
}, data[[n]], m, imp_meth, pred_mat, maxit)
imp_merge[[n]] <<- imp_pairs[[1]]
for (p in 2:length(imp_pairs)) {
imp_merge[[n]] <<- ibind(imp_merge[[n]], imp_pairs[[p]])
}
imp_data <- rbind(imp_data, complete(imp_merge[[n]]))
print(n)
}
return (imp_data)
}
#########################################
# Split vehicles dataset into multiple years
fun_splt_veh <- function(data, tar) {
splt_veh <- list()
tar_names <- names(tar)
splt_veh[[tar_names[1]]] <- data[data$Accident_Index %in% tar[[1]]$Accident_Index, 2:ncol(data)]
for (n in 2:length(tar)) {
splt_veh[[tar_names[n]]] <- data[data$Accident_Index %in% tar[[n]]$Accident_Index, 2:ncol(data)]
}
return (splt_veh)
}
library(mice)
library(dplyr)
library(parallel)
cores_2_use <- detectCores() - 3
veh <- sapply(veh, factor)
veh = read.csv('veh2005_2016-v2018.2.3-tobeimp.csv')
veh <- lapply(veh, factor)
?read.csv
acc <- read.csv('acc2005_2016-v2018.2.3.imp.csv')
excl <- veh[, 'Accident_Index']
excl <- veh[, 1]
excl <- veh[, c('Accident_Index')]
excl <- veh[:, c('Accident_Index')]
veh[1]
excl <- veh['Accident_Index', ]
excl <- veh[1, ]
excl <- veh[, 1]
excl <- veh[, 1:2]
excl <- veh[, 1]
veh <- data.frame(veh)
excl <- veh[, 1]
acc <- acc[, c('Accident_Index', 'Year')]
veh <- fun_splt_veh(veh, acc)
veh <- fun_splt_veh(veh, split(acc, acc$Year))
imp <- mice(bind_rows(veh), maxit = 0)
imp$method
veh <- read.csv('veh2005_2016-v2018.2.3-tobeimp.csv')
veh[veh == -1] <- NA
veh <- veh[, 2:ncol(veh)]
veh <- data.frame(lapply(veh, factor))
summary(veh)
imp <- mice(veh, maxit = 0)
imp$method
meth <- imp$method
predmat <- imp$predictorMatrix
veh <- bind_cols(data.frame(Accident_Index = excl), veh)
excl <- data.frame(Accident_Index = excl)
veh <- fun_splt_veh(veh, split(acc, acc$Year))
remove(acc)
tmp_veh <- lapply(veh, function(x) x[sample(nrow(x), 10000),])
tmp_excl <- excl[1:120000]
tmp_excl <- excl[1:120000,]
tmp_excl <- data.frame(tmp_excl)
runit <- function(data, exclude) {
if(nrow(exclude) > 0 && (nrow(exclude) != sum(sapply(data, nrow)))) {
print('Unbindable data & exclusion rows')
stopCluster(cl)
return
}
imp_cplt <- fun_imp(cl = cl, data = data, X = 1:cores_2_use, m = 2, imp_meth = 'pmm', pred_mat = predmat, maxit = 10)
write.csv(x = bind_cols(exclude, data), file = 'veh2005_2016-v2018.2.3.imp.csv', row.names = FALSE)
saveRDS(object = imp_merge, file = 'veh_imp.RData')
}
cl <- makeCluster(cores_2_use)
clusterSetRNGStream(cl, sample(999999999, 1))
clusterEvalQ(cl, library(mice))
clusterExport(cl, 'tmp_veh')
runit(tmp_veh, tmp_excl)
remove(imp)
runit <- function(data, exclude) {
if(nrow(exclude) > 0 && (nrow(exclude) != sum(sapply(data, nrow)))) {
print('Unbindable data & exclusion rows')
stopCluster(cl)
return
}
imp_cplt <<- fun_imp(cl = cl, data = data, X = 1:cores_2_use, m = 2, imp_meth = 'pmm', pred_mat = predmat, maxit = 10)
write.csv(x = bind_cols(exclude, imp_cplt), file = 'veh2005_2016-v2018.2.3.imp.csv', row.names = FALSE)
saveRDS(object = imp_merge, file = 'veh_imp.RData')
}
runit(tmp_veh, tmp_excl)
gc()
rm(tmp_excl, tmp_veh, imp_cplt)
gc()
plot(imp_merge[[1]])
stopCluster(cl)
cl <- makeCluster(cores_2_use)
clusterSetRNGStream(cl, sample(999999999, 1))
clusterEvalQ(cl, library(mice))
clusterExport(cl, veh)
clusterExport(cl, 'veh')
rm(imp_merge)
gc()
runit
runit <- function(data, exclude) {
if(nrow(exclude) > 0 && (nrow(exclude) != sum(sapply(data, nrow)))) {
print('Unbindable data & exclusion rows')
stopCluster(cl)
return
}
imp_cplt <<- fun_imp(cl = cl, data = data, X = 1:cores_2_use, m = 2, imp_meth = meth, pred_mat = predmat, maxit = 10)
write.csv(x = bind_cols(exclude, imp_cplt), file = 'veh2005_2016-v2018.2.3.imp.csv', row.names = FALSE)
saveRDS(object = imp_merge, file = 'veh_imp.RData')
}
runit(data = veh, exclude = excl)
rm(imp_merge)
predmat
predmat
predmat <- 0
predmat
imp <- mice(bind_rows(veh), maxit = 0)
imp$method
predmat <- imp$predictorMatrix
predmat
predmat[1, !c(2, 5:6)] <- 0
predmat
predmat[1, !c(2, 5:6)] <- 0
predmat
predmat[1, c(3, 4)] <- 0
predmat
predmat[2,] <- 0
predmat
predmat[2, c(3, 4)] <- 1
predmat[3:4, ] <- 0
predmat
predmat[3, c(2)] <- 1
predmat[4, c(2)] <- 1
predmat
rm(imp)
gc()
clusterExport(cl, 'veh')
cl
gc()
clusterExport(cl, 'veh')
predmat
runit(data = veh, exclude = excl)
plot(imp_merge[[4]])
gc()
stopcluster(cl)
stopCluster(cl)
gc()
densityplot(imp_merge[[4]], ~Vehicle_Type)
veh[[5]]
imp <- mice(veh[[5]], maxit = 0)
imp$method
imp$predictorMatrix
imp <- mice(veh[[1]], maxit = 0)
imp$method
imp <- mice(veh[[2]], maxit = 0)
imp$method
imp <- mice(veh[[3]], maxit = 0)
imp$method
imp <- mice(veh[[4]], maxit = 0)
imp$method
imp <- mice(veh[[5]], maxit = 0)
imp$method
imp <- mice(veh[[6]], maxit = 0)
imp$method
fun_tmp
fun_imp
imp_merge[[5]]
predmat[1,]
all(predmat[1,])
any(predmat[1,])
any(predmat[5,])
imp$predictorMatrix
for n in 5:10
for(n in 5:10) {
paste0(n)
}
for(n in 5:10) {
print(n)
}
imp <- mice(veh[[5]], maxit=0, method='polyreg')
imp$method
fun_imp
fun_imp <- function(cl, data, X = 1:detectCores() - 2, m = 1, pred_mat, maxit = 5) {
imp_data <- data[[1]][c(),]
imp_merge <<- vector(mode = 'list', length = length(data))
print('Start Imputation')
for (n in 5:length(data)) {
imp_pairs <- parLapply(cl = cl, X = X, fun = function(no, d, m, predictionMatrix, maxit) {
mice(d, m = m, printFlag = FALSE, maxit = maxit, predictorMatrix = predictionMatrix)
}, data[[n]], m, pred_mat, maxit)
imp_merge[[n]] <<- imp_pairs[[1]]
for (p in 2:length(imp_pairs)) {
imp_merge[[n]] <<- ibind(imp_merge[[n]], imp_pairs[[p]])
}
imp_data <- rbind(imp_data, complete(imp_merge[[n]]))
print(n)
}
return (imp_data)
}
fun_imp <- function(cl, data, X = 1:detectCores() - 2, m = 1, pred_mat, maxit = 5) {
imp_data <- data[[1]][c(),]
imp_merge <<- vector(mode = 'list', length = length(data))
print('Start Imputation')
for (n in 5:length(data)) {
defmat <- mice(data[[n]], maxit = 0)
for (n in 1:nrow(defmat)) {
if any(defmat[n,]) {
defmat[n,] <- pred_mat[n,]
}
}
imp_pairs <- parLapply(cl = cl, X = X, fun = function(no, d, m, predictionMatrix, maxit) {
mice(d, m = m, printFlag = FALSE, maxit = maxit, predictorMatrix = predictionMatrix)
}, data[[n]], m, defmat, maxit)
imp_merge[[n]] <<- imp_pairs[[1]]
for (p in 2:length(imp_pairs)) {
imp_merge[[n]] <<- ibind(imp_merge[[n]], imp_pairs[[p]])
}
print(n)
}
for (n in 1:length(imp_merge)) {
imp_data <- rbind(imp_data, complete(imp_merge[[n]]))
}
return (imp_data)
}
fun_imp <- function(cl, data, X = 1:detectCores() - 2, m = 1, pred_mat, maxit = 5) {
imp_data <- data[[1]][c(),]
imp_merge <<- vector(mode = 'list', length = length(data))
print('Start Imputation')
for (n in 5:length(data)) {
defmat <- mice(data[[n]], maxit = 0)
for (n in 1:nrow(defmat)) {
if any(defmat[n,]) {
defmat[n,] <- pred_mat[n,]
}
}
imp_pairs <- parLapply(cl = cl, X = X, fun = function(no, d, m, predictionMatrix, maxit) {
mice(d, m = m, printFlag = FALSE, maxit = maxit, predictorMatrix = predictionMatrix)
}, data[[n]], m, defmat, maxit)
imp_merge[[n]] <<- imp_pairs[[1]]
for (p in 2:length(imp_pairs)) {
imp_merge[[n]] <<- ibind(imp_merge[[n]], imp_pairs[[p]])
}
print(n)
}
for (n in 1:length(imp_merge)) {
imp_data <- rbind(imp_data, complete(imp_merge[[n]]))
}
return (imp_data)
}
fun_imp <- function(cl, data, X = 1:detectCores() - 2, m = 1, pred_mat, maxit = 5) {
imp_data <- data[[1]][c(),]
imp_merge <<- vector(mode = 'list', length = length(data))
print('Start Imputation')
for (n in 5:length(data)) {
defmat <- mice(data[[n]], maxit = 0)
for (n in 1:nrow(defmat)) {
if (any(defmat[n,])) {
defmat[n,] <- pred_mat[n,]
}
}
imp_pairs <- parLapply(cl = cl, X = X, fun = function(no, d, m, predictionMatrix, maxit) {
mice(d, m = m, printFlag = FALSE, maxit = maxit, predictorMatrix = predictionMatrix)
}, data[[n]], m, defmat, maxit)
imp_merge[[n]] <<- imp_pairs[[1]]
for (p in 2:length(imp_pairs)) {
imp_merge[[n]] <<- ibind(imp_merge[[n]], imp_pairs[[p]])
}
print(n)
}
for (n in 1:length(imp_merge)) {
imp_data <- rbind(imp_data, complete(imp_merge[[n]]))
}
return (imp_data)
}
rm(imp)
runit
runit <- function(data, exclude) {
if(nrow(exclude) > 0 && (nrow(exclude) != sum(sapply(data, nrow)))) {
print('Unbindable data & exclusion rows')
stopCluster(cl)
return
}
imp_cplt <<- fun_imp(cl = cl, data = data, X = 1:cores_2_use, m = 2, pred_mat = predmat, maxit = 10)
write.csv(x = bind_cols(exclude, imp_cplt), file = 'veh2005_2016-v2018.2.3.imp.csv', row.names = FALSE)
saveRDS(object = imp_merge, file = 'veh_imp.RData')
}
veh[[5:length(veh)]]
veh[[5]]
veh[[5:7]]
saveRDS(imp_merge, 'partial_veh_imp_4.RData')
rm(meth, n)
fun_imp
runit
fun_imp <- function(cl, data, X = 1:detectCores() - 2, m = 1, pred_mat, maxit = 5) {
imp_data <- data[[1]][c(),]
imp_merge <<- vector(mode = 'list', length = length(data))
print('Start Imputation')
for (n in 5:length(data)) {
defmat <- mice(data[[n]], maxit = 0)$predictorMatrix
for (n in 1:nrow(defmat)) {
if (any(defmat[n,])) {
defmat[n,] <- pred_mat[n,]
}
}
imp_pairs <- parLapply(cl = cl, X = X, fun = function(no, d, m, predictionMatrix, maxit) {
mice(d, m = m, printFlag = FALSE, maxit = maxit, predictorMatrix = predictionMatrix)
}, data[[n]], m, defmat, maxit)
imp_merge[[n]] <<- imp_pairs[[1]]
for (p in 2:length(imp_pairs)) {
imp_merge[[n]] <<- ibind(imp_merge[[n]], imp_pairs[[p]])
}
print(n)
}
for (n in 1:length(imp_merge)) {
imp_data <- rbind(imp_data, complete(imp_merge[[n]]))
}
return (imp_data)
}
cl <- makeCluster(cores_2_use)
clusterSetRNGStream(cl, sample(999999999, 1))
clusterEvalQ(cl, library(mice))
clusterExport(cl, 'veh')
runit(data = veh, exclude = excl)
stopCluster(cl)
gc()
fun_imp
warnings()
tmp <- lapply(veh, function(x) x[sample(nrow(x), 10000)])
tmp <- lapply(veh, function(x) x[sample(nrow(x), 10000),])
cl <- makeCluster(cores_2_use)
clusterSetRNGStream(cl, 123)
clusterEvalQ(cl, library(mice))
imp_merge <- readRDS(file = 'partial_veh_imp_4.RData')
imp_merge[[5]]
fun_imp
fun_imp <- function(cl, data, X = 1:detectCores() - 2, m = 1, pred_mat, maxit = 5) {
imp_data <- data[[1]][c(),]
print('Start Imputation')
for (n in 5:length(data)) {
defmat <- mice(data[[n]], maxit = 0)$predictorMatrix
for (n in 1:nrow(defmat)) {
if (any(defmat[n,])) {
defmat[n,] <- pred_mat[n,]
}
}
imp_pairs <- parLapply(cl = cl, X = X, fun = function(no, d, m, predictionMatrix, maxit) {
mice(d, m = m, printFlag = FALSE, maxit = maxit, predictorMatrix = predictionMatrix)
}, data[[n]], m, defmat, maxit)
imp_merge[[n]] <<- imp_pairs[[1]]
for (p in 2:length(imp_pairs)) {
imp_merge[[n]] <<- ibind(imp_merge[[n]], imp_pairs[[p]])
}
print(n)
}
for (n in 1:length(imp_merge)) {
imp_data <- rbind(imp_data, complete(imp_merge[[n]]))
}
return (imp_data)
}
cl
imp_cplt <- fun_imp(cl = cl, data = tmp, X = 1:cores_2_use, m = 2, pred_mat = predmat, maxit = 10)
imp_merge[[7]]
imp_merge[[6]]
for (n in 5:length(veh)) {
print(n)
}
fun_imp
fun_imp <- function(cl, data, X = 1:detectCores() - 2, m = 1, pred_mat, maxit = 5) {
imp_data <- data[[1]][c(),]
print('Start Imputation')
for (n in 5:length(data)) {
defmat <- mice(data[[n]], maxit = 0)$predictorMatrix
for (r in 1:nrow(defmat)) {
if (any(defmat[r,])) {
defmat[r,] <- pred_mat[r,]
}
}
imp_pairs <- parLapply(cl = cl, X = X, fun = function(no, d, m, predictionMatrix, maxit) {
mice(d, m = m, printFlag = FALSE, maxit = maxit, predictorMatrix = predictionMatrix)
}, data[[n]], m, defmat, maxit)
imp_merge[[n]] <<- imp_pairs[[1]]
for (p in 2:length(imp_pairs)) {
imp_merge[[n]] <<- ibind(imp_merge[[n]], imp_pairs[[p]])
}
print(n)
}
for (n in 1:length(imp_merge)) {
imp_data <- rbind(imp_data, complete(imp_merge[[n]]))
}
return (imp_data)
}
imp_cplt <- fun_imp(cl = cl, data = tmp, X = 1:cores_2_use, m = 2, pred_mat = predmat, maxit = 10)
imp_merge[[5]]$method
imp_merge[[6]]$method
imp_merge[[7]]$method
imp_merge[[8]]$method
imp_merge[[9]]$method
imp_merge[[10]]$method
imp_merge[[11]]$method
imp <- mice(veh[[11]], maxit = 0)
imp$method
imp$predictorMatrix
fun_imp
predmat
imp$predictorMatrix
fun_imp
imp <- mice(tmp[[11]], predictorMatrix = predmat)
unique(tmp[[11]]$Vehicle_Type)
length(unique(tmp[[11]]$Vehicle_Type))
imp <- mice(tmp[[12]], predictorMatrix = predmat)
imp <- mice(tmp[[11]])
tmp[[11]]$Vehicle_Type <- factor(tmp[[11]]$Vehicle_Type)
unique(tmp[[11]]$Vehicle_Type)
imp <- mice(tmp[[11]], predictorMatrix = predmat)
rm(tmp, imp)
rm(impmerge)
rm(imp_merge)
gc()
imp_merge <- readRDS(file = 'partial_veh_imp_4.RData')
tmp <- lapply(veh, function(x) x[sample(nrow(x), 10000),])
tmp <- lapply(tmp, function(x) lapply(x, factor))
imp_cplt <- fun_imp(cl = cl, data = tmp, X = 1:cores_2_use, m = 1, pred_mat = predmat, maxit = 1)
tmp <- lapply(tmp, function(x) data.frame(lapply(x, factor)))
imp_cplt <- fun_imp(cl = cl, data = tmp, X = 1:cores_2_use, m = 1, pred_mat = predmat, maxit = 1)
simmary(imp_cplt)
summary(imp_cplt)
rm(imp_cplt, tmp, imp_merge)
imp_merge <- readRDS(file = 'partial_veh_imp_4.RData')
veh <- lapply(veh, function(x) data.frame(lapply(x, factor)))
gc()
imp_merge[[5]]
imp_merge[[4]]
gc()
stopCluster(cl)
cl <- makeCluster(cores_2_use)
clusterSetRNGStream(cl, sample(99999999, 1))
clusterEvalQ(cl, library(mice))
runit(data = veh, exclude = excl)
warnings()
stopCluster(cl)
gc()
imo_merge[[5]]
imp_merge[[5]]
imp_merge[[6]]
imp_merge[[7]]
imp_merge[[8]]
saveRDS(predmat, 'veh_imp_predictorMatrix.RData')
plot(imp_merge[[10]])
densityplot(imp_merge[[10]])
densityplot(imp_merge[[10]], ~Vehicle_Type)
imp_merge[[10]]$lastSeedvalue
imp_merge[[10]]$predictorMatrix
imp_merge[[10]]
imp_merge[[10]]$data
densityplot(imp_merge[[10]]$data, ~Vehicle_Type)
densityplot(imp_merge[[10]]$chainVar, ~Vehicle_Type)
densityplot(imp_merge[[10]]$where, ~Vehicle_Type)
densityplot(imp_merge[[10]]$imp, ~Vehicle_Type)
